use std::path::PathBuf;
use std::process::Command;
use anyhow::Result;
use serde::{Deserialize, Serialize};
use tokio::process::Command as AsyncCommand;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use uuid;
use reqwest;
use serde_json::Value;
use std::time::Duration;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitConfig {
    pub timeout: u64,
    pub memory_limit: u64,
    pub cpu_limit: u64,
    pub network_access: bool,
    pub filesystem_access: bool,
    pub allowed_ports: Vec<u16>,
    pub metasploit_path: Option<PathBuf>,
    pub exploit_validation: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceLimits {
    pub max_memory_mb: u64,
    pub max_cpu_percent: u64,
    pub max_duration_seconds: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitResult {
    pub success: bool,
    pub output: String,
    pub session_id: Option<String>,
    pub error: Option<String>,
    pub validation_result: Option<ExploitValidation>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitValidation {
    pub is_valid: bool,
    pub checks_passed: Vec<String>,
    pub checks_failed: Vec<String>,
    pub warnings: Vec<String>,
}

pub struct ExploitExecutor {
    config: ExploitConfig,
    resource_limits: ResourceLimits,
    sandbox_dir: PathBuf,
    active_exploits: Arc<Mutex<HashMap<String, tokio::process::Child>>>,
    metasploit_client: Option<MetasploitClient>,
}

struct MetasploitClient {
    client: reqwest::Client,
    base_url: String,
    api_key: String,
}

impl MetasploitClient {
    async fn new(host: &str, port: u16, api_key: &str) -> Result<Self> {
        let client = reqwest::Client::new();
        let base_url = format!("http://{}:{}/api/v1", host, port);
        
        // Test connection and authenticate
        let response = client
            .post(&format!("{}/auth/login", base_url))
            .json(&serde_json::json!({
                "username": "msf",
                "password": api_key
            }))
            .send()
            .await?;
            
        if !response.status().is_success() {
            return Err(anyhow::anyhow!("Failed to authenticate with Metasploit"));
        }

        let token = response.json::<Value>().await?["token"].as_str()
            .ok_or_else(|| anyhow::anyhow!("No token in response"))?;
        
        Ok(Self {
            client,
            base_url,
            api_key: token.to_string(),
        })
    }
    
    async fn execute_exploit(&self, module: &str, target: &str, options: HashMap<String, String>) -> Result<ExploitResult> {
        // First, check if module exists
        let module_info = self.client
            .get(&format!("{}/modules/exploit/{}", self.base_url, module))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await?;
            
        if !module_info.status().is_success() {
            return Err(anyhow::anyhow!("Module not found or not accessible"));
        }

        // Create a job for the exploit
        let job_response = self.client
            .post(&format!("{}/modules/exploit/{}/execute", self.base_url, module))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(&serde_json::json!({
                "target": target,
                "options": options
            }))
            .send()
            .await?;
            
        if !job_response.status().is_success() {
            return Err(anyhow::anyhow!("Failed to start exploit job"));
        }

        let job_id = job_response.json::<Value>().await?["job_id"].as_str()
            .ok_or_else(|| anyhow::anyhow!("No job ID in response"))?;

        // Poll for job completion
        let mut attempts = 0;
        let max_attempts = 30; // 30 seconds timeout
        
        while attempts < max_attempts {
            let status_response = self.client
                .get(&format!("{}/jobs/{}", self.base_url, job_id))
                .header("Authorization", format!("Bearer {}", self.api_key))
                .send()
                .await?;
                
            if !status_response.status().is_success() {
                return Err(anyhow::anyhow!("Failed to get job status"));
            }

            let status = status_response.json::<Value>().await?;
            if status["status"].as_str() == Some("completed") {
                // Get job output
                let output_response = self.client
                    .get(&format!("{}/jobs/{}/output", self.base_url, job_id))
                    .header("Authorization", format!("Bearer {}", self.api_key))
                    .send()
                    .await?;
                    
                if !output_response.status().is_success() {
                    return Err(anyhow::anyhow!("Failed to get job output"));
                }

                let output = output_response.json::<Value>().await?;
                
                return Ok(ExploitResult {
                    success: output["success"].as_bool().unwrap_or(false),
                    output: output["output"].as_str().unwrap_or("").to_string(),
                    session_id: output["session_id"].as_str().map(|s| s.to_string()),
                    error: output["error"].as_str().map(|s| s.to_string()),
                    validation_result: None,
                });
            } else if status["status"].as_str() == Some("failed") {
                return Err(anyhow::anyhow!("Exploit job failed: {}", 
                    status["error"].as_str().unwrap_or("Unknown error")));
            }

            tokio::time::sleep(Duration::from_secs(1)).await;
            attempts += 1;
        }

        Err(anyhow::anyhow!("Exploit job timed out"))
    }

    async fn list_modules(&self) -> Result<Vec<String>> {
        let response = self.client
            .get(&format!("{}/modules/exploit", self.base_url))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await?;
            
        if !response.status().is_success() {
            return Err(anyhow::anyhow!("Failed to list modules"));
        }

        let modules = response.json::<Value>().await?;
        Ok(modules.as_array()
            .ok_or_else(|| anyhow::anyhow!("Invalid modules response"))?
            .iter()
            .filter_map(|m| m["fullname"].as_str().map(|s| s.to_string()))
            .collect())
    }

    async fn get_module_info(&self, module: &str) -> Result<Value> {
        let response = self.client
            .get(&format!("{}/modules/exploit/{}", self.base_url, module))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await?;
            
        if !response.status().is_success() {
            return Err(anyhow::anyhow!("Failed to get module info"));
        }

        Ok(response.json().await?)
    }

    async fn create_session(&self, session_type: &str, options: HashMap<String, String>) -> Result<String> {
        let response = self.client
            .post(&format!("{}/sessions", self.base_url))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(&serde_json::json!({
                "type": session_type,
                "options": options
            }))
            .send()
            .await?;
            
        if !response.status().is_success() {
            return Err(anyhow::anyhow!("Failed to create session"));
        }

        let session = response.json::<Value>().await?;
        Ok(session["id"].as_str()
            .ok_or_else(|| anyhow::anyhow!("No session ID in response"))?
            .to_string())
    }

    async fn interact_with_session(&self, session_id: &str, command: &str) -> Result<String> {
        let response = self.client
            .post(&format!("{}/sessions/{}/interact", self.base_url, session_id))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(&serde_json::json!({
                "command": command
            }))
            .send()
            .await?;
            
        if !response.status().is_success() {
            return Err(anyhow::anyhow!("Failed to interact with session"));
        }

        let result = response.json::<Value>().await?;
        Ok(result["output"].as_str()
            .ok_or_else(|| anyhow::anyhow!("No output in response"))?
            .to_string())
    }
}

impl ExploitExecutor {
    pub fn new(config: ExploitConfig, resource_limits: ResourceLimits) -> Result<Self> {
        let sandbox_dir = std::env::temp_dir().join("sarissa_sandbox");
        std::fs::create_dir_all(&sandbox_dir)?;

        // Set up secure sandbox directory permissions
        std::fs::set_permissions(&sandbox_dir, std::fs::Permissions::from_mode(0o700))?;

        let metasploit_client = if let Some(msf_path) = &config.metasploit_path {
            // Start Metasploit RPC server if not running
            if !Self::is_metasploit_running()? {
                Self::start_metasploit_rpc(msf_path)?;
            }
            
            // Connect to Metasploit with retry logic
            let client = tokio::runtime::Runtime::new()?
                .block_on(async {
                    let mut retries = 3;
                    let mut last_error = None;
                    
                    while retries > 0 {
                        match MetasploitClient::new("127.0.0.1", 55553, "your_api_key").await {
                            Ok(client) => return Ok(client),
                            Err(e) => {
                                last_error = Some(e);
                                retries -= 1;
                                tokio::time::sleep(Duration::from_secs(2)).await;
                            }
                        }
                    }
                    
                    Err(last_error.unwrap_or_else(|| anyhow::anyhow!("Failed to connect to Metasploit")))
                })?;
            Some(client)
        } else {
            None
        };

        Ok(Self {
            config,
            resource_limits,
            sandbox_dir,
            active_exploits: Arc::new(Mutex::new(HashMap::new())),
            metasploit_client,
        })
    }

    fn is_metasploit_running() -> Result<bool> {
        let output = Command::new("ps")
            .args(&["aux"])
            .output()?;
            
        Ok(String::from_utf8_lossy(&output.stdout)
            .contains("msfrpcd"))
    }

    fn start_metasploit_rpc(msf_path: &PathBuf) -> Result<()> {
        Command::new(msf_path.join("msfrpcd"))
            .args(&["-P", "your_password", "-a", "127.0.0.1", "-p", "55553"])
            .spawn()?;
            
        // Wait for server to start
        std::thread::sleep(Duration::from_secs(5));
        Ok(())
    }

    pub async fn execute_exploit(&self, exploit_path: &str, target: &str, port: u16) -> Result<ExploitResult> {
        // Validate exploit path
        let exploit_path = std::path::Path::new(exploit_path);
        if !exploit_path.exists() {
            return Err(anyhow::anyhow!("Exploit file not found"));
        }

        // Validate target
        if !self.validate_target(target)? {
            return Err(anyhow::anyhow!("Invalid target"));
        }

        // Validate port
        if !self.validate_port(port)? {
            return Err(anyhow::anyhow!("Invalid port"));
        }

        // Validate exploit
        let validation = if self.config.exploit_validation {
            self.validate_exploit(exploit_path.to_str().unwrap()).await?
        } else {
            None
        };

        // Create sandbox environment with unique ID
        let sandbox_id = uuid::Uuid::new_v4();
        let sandbox_path = self.sandbox_dir.join(format!("exploit_{}", sandbox_id));
        std::fs::create_dir_all(&sandbox_path)?;

        // Set secure permissions for sandbox
        std::fs::set_permissions(&sandbox_path, std::fs::Permissions::from_mode(0o700))?;

        // Copy exploit to sandbox with secure permissions
        let exploit_dest = sandbox_path.join("exploit");
        std::fs::copy(exploit_path, &exploit_dest)?;
        std::fs::set_permissions(&exploit_dest, std::fs::Permissions::from_mode(0o500))?;

        // Set up resource limits
        let mut command = AsyncCommand::new("cgexec");
        command
            .arg("-g")
            .arg(format!("memory:sarissa_{}", sandbox_id))
            .arg("--")
            .arg(&exploit_dest)
            .arg(target)
            .arg(port.to_string());

        // Set resource limits
        if self.config.network_access {
            command.env("SARISSA_NETWORK_ACCESS", "1");
        }
        if self.config.filesystem_access {
            command.env("SARISSA_FILESYSTEM_ACCESS", "1");
        }

        // Execute exploit with timeout and resource monitoring
        let output = tokio::time::timeout(
            std::time::Duration::from_secs(self.config.timeout),
            command.output(),
        )
        .await??;

        // Clean up sandbox
        self.cleanup_sandbox(&sandbox_path)?;

        Ok(ExploitResult {
            success: output.status.success(),
            output: String::from_utf8_lossy(&output.stdout).to_string(),
            session_id: None,
            error: if !output.status.success() {
                Some(String::from_utf8_lossy(&output.stderr).to_string())
            } else {
                None
            },
            validation_result: validation,
        })
    }

    fn validate_target(&self, target: &str) -> Result<bool> {
        // Basic IP address validation
        if !target.contains('.') {
            return Ok(false);
        }

        let parts: Vec<&str> = target.split('.').collect();
        if parts.len() != 4 {
            return Ok(false);
        }

        for part in parts {
            match part.parse::<u8>() {
                Ok(_) => continue,
                Err(_) => return Ok(false),
            }
        }

        Ok(true)
    }

    fn validate_port(&self, port: u16) -> Result<bool> {
        // Check if port is in allowed range
        if port == 0 || port > 65535 {
            return Ok(false);
        }

        // Check if port is in allowed ports list
        if !self.config.allowed_ports.is_empty() && !self.config.allowed_ports.contains(&port) {
            return Ok(false);
        }

        Ok(true)
    }

    async fn validate_exploit(&self, exploit_path: &str) -> Result<Option<ExploitValidation>> {
        let mut checks_passed = Vec::new();
        let mut checks_failed = Vec::new();
        let mut warnings = Vec::new();

        // Check file permissions
        let metadata = std::fs::metadata(exploit_path)?;
        if metadata.permissions().readonly() {
            checks_failed.push("Exploit file is read-only".to_string());
        } else {
            checks_passed.push("File permissions are valid".to_string());
        }

        // Check for dangerous operations
        let content = std::fs::read_to_string(exploit_path)?;
        if content.contains("system") || content.contains("exec") {
            warnings.push("Exploit contains system calls".to_string());
        }

        // Check for proper error handling
        if !content.contains("try") && !content.contains("catch") {
            warnings.push("Exploit lacks error handling".to_string());
        }

        // Check for proper cleanup
        if !content.contains("cleanup") && !content.contains("finally") {
            warnings.push("Exploit lacks cleanup code".to_string());
        }

        Ok(Some(ExploitValidation {
            is_valid: checks_failed.is_empty(),
            checks_passed,
            checks_failed,
            warnings,
        }))
    }

    pub async fn stop_exploit(&self, exploit_id: &str) -> Result<()> {
        let mut active_exploits = self.active_exploits.lock().await;
        if let Some(mut child) = active_exploits.remove(exploit_id) {
            child.kill().await?;
        }
        Ok(())
    }

    pub async fn get_exploit_status(&self, exploit_id: &str) -> Result<Option<i32>> {
        let active_exploits = self.active_exploits.lock().await;
        if let Some(child) = active_exploits.get(exploit_id) {
            Ok(child.id())
        } else {
            Ok(None)
        }
    }

    fn cleanup_sandbox(&self, sandbox_path: &std::path::Path) -> Result<()> {
        // Remove all files in sandbox
        if sandbox_path.exists() {
            std::fs::remove_dir_all(sandbox_path)?;
        }

        // Remove cgroup
        let cgroup_name = format!("sarissa_{}", sandbox_path.file_name().unwrap().to_string_lossy());
        Command::new("cgdelete")
            .arg("-g")
            .arg(format!("memory:{}", cgroup_name))
            .status()?;

        Ok(())
    }
}

// Sandbox configuration
impl ExploitExecutor {
    fn setup_sandbox(&self) -> Result<()> {
        // Create cgroup for resource limiting
        Command::new("cgcreate")
            .arg("-g")
            .arg(format!("memory:sarissa_{}", uuid::Uuid::new_v4()))
            .status()?;

        // Set memory limit
        Command::new("cgset")
            .arg("-r")
            .arg(format!("memory.limit_in_bytes={}", self.resource_limits.max_memory_mb * 1024 * 1024))
            .arg(format!("sarissa_{}", uuid::Uuid::new_v4()))
            .status()?;

        // Set CPU limit
        Command::new("cgset")
            .arg("-r")
            .arg(format!("cpu.cfs_quota_us={}", self.resource_limits.max_cpu_percent * 10000))
            .arg(format!("sarissa_{}", uuid::Uuid::new_v4()))
            .status()?;

        Ok(())
    }

    fn cleanup_sandbox(&self) -> Result<()> {
        Command::new("cgdelete")
            .arg("-g")
            .arg(format!("memory:sarissa_{}", uuid::Uuid::new_v4()))
            .status()?;

        Ok(())
    }
} 